"""Define the base class of task, which will be used for defining more tasks."""

import inspect
from abc import ABC, abstractmethod
from inspect import getfullargspec
from typing import TYPE_CHECKING, Any, Optional

from bson.objectid import ObjectId
from pydantic import BaseModel

from alab_management.builders.experimentbuilder import ExperimentBuilder
from alab_management.builders.samplebuilder import SampleBuilder
from alab_management.task_view.task_enums import TaskPriority

if TYPE_CHECKING:
    from alab_management.lab_view import LabView


class ResultPointer:
    """A reference to a result generated by a task. This result can then be imported by another task."""

    def __init__(self, task_id: ObjectId, key: str):
        self.task_id = task_id
        self.key = key

    def to_json(self):
        """Convert this ResultPointer to a JSON-serializable dictionary."""
        return {
            "type": "ResultPointer",
            "task_id": str(self.task_id),
            "key": self.key,
        }

    @classmethod
    def from_json(cls, json: dict[str, Any]):
        """Create a ResultPointer from a JSON-serializable dictionary."""
        if json["type"] != "ResultPointer":
            raise ValueError("JSON does not encode a ResultPointer!")
        return cls(task_id=ObjectId(json["task_id"]), key=json["key"])


class BaseTask(ABC):
    """
    The abstract class of task.

    All the tasks should inherit from this class.
    """

    def __init__(
        self,
        samples: list[str | ObjectId] | None = None,
        task_id: ObjectId | None = None,
        lab_view: Optional["LabView"] = None,
        priority: TaskPriority | int | None = TaskPriority.NORMAL,
        offline_mode: bool = True,
        *args,
        **kwargs,
    ):
        """
        Args:
            task_id: the identifier of task
            lab_view: a lab_view corresponding to the task_id
            samples: a list of sample_id's corresponding to samples involvend in the task.
            offline_mode: whether the task is run in offline mode or not. It is in offline mode when you
              are trying to build an experiment out of it or get the task result.

        Here is an example about how to define a custom task

        .. code-block:: python

          def __init__(self, sample_1: ObjectId, sample_2: Optional[ObjectId],
                       sample_3: Optional[ObjectId], sample_4: Optional[ObjectId],
                        setpoints: List[Tuple[float, float]], *args, **kwargs):
              super(Heating, self).__init__(*args, **kwargs)
              self.setpoints = setpoints
              self.samples = [sample_1, sample_2, sample_3, sample_4]
        """
        self.__offline = offline_mode
        self._is_taskid_generated = (
            False  # whether the task_id is generated using ObjectId() here or not
        )

        self.__samples = samples or []
        if self.is_offline:
            if task_id is None:  # if task_id is not provided, generate one
                self._is_taskid_generated = True
                task_id = ObjectId()
            self.task_id = task_id
            current_frame = inspect.currentframe()
            outer_frames = inspect.getouterframes(current_frame)
            subclass_init_frame = outer_frames[1].frame
            self.subclass_kwargs = {
                key: val
                for key, val in inspect.getargvalues(subclass_init_frame).locals.items()
                if key not in ["self", "args", "kwargs", "__class__"]
            }
            if not self.validate():
                raise ValueError("Task validation failed!")
        else:
            if (task_id is None) or (lab_view is None) or (samples is None):
                raise ValueError(
                    "BaseTask was instantiated with offline mode off -- task_id, "
                    "lab_view, and samples must all be provided!"
                )
            self.task_id = task_id
            self.lab_view = lab_view
            self.logger = self.lab_view.logger
            self.priority = priority
            self.lab_view.priority = priority

    @property
    def is_offline(self) -> bool:
        """Returns True if this task is in offline, False if it is a live task."""
        return self.__offline

    @property
    def samples(self) -> list[str]:
        """Returns the list of samples associated with this task."""
        return self.__samples

    @property
    def priority(self) -> int:
        """Returns the priority of this task."""
        if self.is_offline:
            return 0
        return self.lab_view._resource_requester.priority

    @property
    @abstractmethod
    def result_specification(self) -> type[BaseModel]:
        """Returns a dictionary describing the results to be generated by this task.

        Raises
        ------
            NotImplementedError: The subclass must implement this method.

        Returns
        -------
            BaseModel: A Pydantic model describing the results to be generated by this task.
        """
        raise NotImplementedError(
            "The .result_specification method must be implemented by a subclass of BaseTask."
        )

    def update_result(self, key: str, value: Any):
        """Attach a result to the task. This will be saved in the database and
        can be accessed later. Subsequent calls to this function with the same
        key will overwrite the previous value.

        Args:
            key (str): The name of the result.
            value (Any): The value of the result.
        """
        if key not in self.result_specification:
            raise ValueError(
                f"Result key {key} is not included in the result specification for this task!"
            )

        # TODO type checking?

        if not self.__offline:
            self.lab_view.update_result(name=key, value=value)

    def export_result(self, key: str) -> dict:
        """
        Creates a reference to a result generated by this Task. This
        result can then be imported by another task. This is useful in
        cases where tasks are chained together. For instance, the
        diffraction results from a "PowderDiffraction" task could be
        exported, then imported by a "RietveldRefinement" analysis task.

        Args:
            key (str): The name of the result.

        Returns
        -------
            Any: The value of the result.
        """
        if self._is_taskid_generated:
            raise ValueError(
                "Cannot export a result from a task with an automatically generated task_id!"
            )
        if key not in self.result_specification:
            raise ValueError(
                f"Result key {key} is not included in the result specification for this task!"
            )

        return ResultPointer(task_id=self.task_id, key=key).to_json()

    def import_result(
        self,
        pointer: ResultPointer | dict[str, Any],
        allow_explicit_value: bool = False,
    ) -> Any:
        """
        Imports a result from another task. This is useful in cases where
        tasks are chained together. For instance, the diffraction results from a
        ``PowderDiffraction`` task could be exported, then imported by a "RietveldRefinement"
        analysis task.

        Args:
            pointer (Union[ResultPointer, Dict[str, Any]]): Either a ResultPointer object
              or a dictionary with the same format as a ResultPointer.
            allow_explicit_value (bool, optional): If true, users can pass values here instead
              of pointers. If False, only ResultPointers are valid. Defaults to False.

        Raises
        ------
            ValueError: If allow_explicit_value is False and the user passes a value instead of a pointer.

        Returns
        -------
            Any: The value of the result.
        """
        if isinstance(pointer, dict) and pointer.get("type", None) == "ResultPointer":
            pointer = ResultPointer.from_json(pointer)
        elif isinstance(pointer, ResultPointer):
            pass  # already in correct format
        else:
            if allow_explicit_value:
                return pointer  # user passed a specific value instead of a pointer
            else:
                raise ValueError(
                    f"Invalid pointer: {pointer}. This value was expected to be a pointer "
                    f"to an existing task result, but an explicit value was passed instead! "
                    f"If you want to allow explicit values, set allow_explicit_value=True."
                )

        reference_task = self.lab_view._task_view.get_task(task_id=pointer.task_id)
        return reference_task["result"][pointer.key]

    @priority.setter
    def priority(self, value: int | TaskPriority):
        if value < 0:
            raise ValueError("Priority should be a positive integer")
        if not self.__offline:
            self.lab_view._resource_requester.priority = int(value)

    def set_message(self, message: str):
        """Sets the task message to be displayed on the dashboard."""
        self._message = message
        if not self.__offline:
            self.lab_view._task_view.set_message(task_id=self.task_id, message=message)

    def get_message(self):
        """Gets the task message to be displayed on the dashboard."""
        return self._message

    def validate(self) -> bool:
        """
        Validate the task.

        This function will be called before the task is executed.
        Should return False if the task has values that make it impossible to execute.
        For example, a ``Heating`` subclass of `BaseTask` might return False if the
        set temperature is too high for the furnace.

        By default, this function returns True unless it is overridden by a subclass.
        """
        return True

    @abstractmethod
    def run(self):
        """
        Run the task. In this function, you can request lab resources from lab manager and log data to database
        with logger.

        ``request_resources`` will not return until all the requested resources are available. So the task will
        pend until it gets the requested resources, which prevent the conflict in the resource allocation.

        When a device get the requested device and sample positions, it also takes over the ownership of these
        resources, i.e., other task cannot use the device or request the sample positions this task has requested.

        We use a context manager to manage the ownership of the resources. when a task is completed, all the devices
        and sample positions will be released automatically.

        Here is an example about how to define the task

        .. code-block:: python

          # request devices and sample positions from lab manager. The `$` represents
          # the name of assigned devices in the sample positions we try to request,
          # 4 is the number of sample positions.
          with self.lab_view.request_resources({Furnace: [("$.inside", 4)]}) as devices_and_positions:
              devices, sample_positions = devices_and_positions
              furnace = devices[Furnace]
              inside_furnace = sample_positions[Furnace]["$.inside"]

              for sample in self.samples:
                  # in a task, we can call other tasks, which will share the same
                  # task id, requested devices and sample positions.
                  moving_task = Moving(sample=sample,
                                       task_id=self.task_id,
                                       dest=inside_furnace[0],
                                       lab_view=self.lab_view,
                                       logger=self.logger)
                  moving_task.run()

              # send command to device
              furnace.run_program(self.setpoints)

              while furnace.is_running():
                  # log the device data, which is current temperature of the furnace
                  self.logger.log_device_signal({
                      "device": furnace.name,
                      "temperature": furnace.get_temperature(),
                  })

        """
        raise NotImplementedError(
            "The .run method must be implemented by the subclass of BaseTask."
        )

    def run_subtask(
        self,
        task: type["BaseTask"],
        samples: list[str] | str | None = None,
        **kwargs,
    ):
        """Run a subtask of this current task. Returns the result, if any, of the subtask."""
        samples = samples or self.samples
        if isinstance(samples, str):
            samples = [samples]
        return self.lab_view.run_subtask(task=task, samples=samples, **kwargs)

    def add_to(
        self,
        samples: SampleBuilder | list[SampleBuilder],
    ):
        """Used to add basetask to a SampleBuilder's tasklist during Experiment construction.

        Args: samples (Union[SampleBuilder, List[SampleBuilder]]): One or more SampleBuilder's which will have this
        task appended to their tasklists.
        """
        if not self.__offline:
            raise RuntimeError(
                "Cannot add a live BaseTask instance to a SampleBuilder. BaseTask must be instantiated with "
                "`offline_mode=True` to enable this method."
            )
        if isinstance(samples, SampleBuilder):
            samples = [samples]

        experiment: ExperimentBuilder = samples[0].experiment
        task_id = str(ObjectId())
        experiment.add_task(
            task_id=task_id,
            task_name=self.__class__.__name__,
            task_kwargs=self.subclass_kwargs,
            samples=samples,
        )
        for sample in samples:
            sample.add_task(task_id=task_id)


_task_registry: dict[str, type[BaseTask]] = {}

SUPPORTED_SAMPLE_POSITIONS_TYPE = dict[type["BaseDevice"] | str | None, str | list[str]]
_reroute_task_registry: list[
    dict[str, type[BaseTask] | SUPPORTED_SAMPLE_POSITIONS_TYPE]
] = []


def add_task(task: type[BaseTask]):
    """Register a task."""
    if task.__name__ in _task_registry:
        raise KeyError(f"Duplicated operation name {task.__name__}")
    _task_registry[task.__name__] = task


def get_all_tasks() -> dict[str, type[BaseTask]]:
    """Get all the tasks in the registry."""
    return _task_registry.copy()


def add_reroute_task(
    supported_sample_positions: SUPPORTED_SAMPLE_POSITIONS_TYPE,
    task: type[BaseTask],
    **kwargs,
):
    """Register a reroute task."""
    if task.__name__ not in _task_registry:
        raise KeyError(
            f"Task {task.__name__} is not registered! Register with `add_task` before registering as a reroute task."
        )
    if "sample" not in getfullargspec(task).args:
        raise ValueError(
            f"Task {task.__name__} does not have `sample` as a parameter! "
            "Reroute tasks must accept a `sample` parameter that specifies the name or sample_id of the sample to be "
            "rerouted"
        )
    _reroute_task_registry.append(
        {
            "supported_sample_positions": supported_sample_positions,
            "task": task,
            "kwargs": kwargs,
        }
    )
